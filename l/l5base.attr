/*
 * define attribute defun
 * (defun (args...) (body)...)
 */
VDEFATTR(defun,"defun",{
    vps_closure_req* jreq;
    vclosure* closure;
    vast_obj* obj;
    vast_obj* next;
    vast_symbol* fun_name;
    vcfg_graph* grp;
    vast_obj* args;
    vps_inst* inst;

    jreq = (vps_closure_req*)req;

    closure = vclosure_new(jreq->vps);
    if (!closure) {
      uabort("new closure error!");
    }
    closure->parent = jreq->closure;
    grp = closure->init;
    grp->scope = VPS_SCOPE_GLOBAL;

    next = vast_cdr(jreq->ast_obj);
    if (vast_consp(next)) {
      uabort("not define funcion name!");
    }
    obj = vast_car(next);
    if (vast_symbolp(obj)) {
      uabort("has no function name!");
    }
    fun_name = (vast_symbol*)obj;

    grp->id.name = fun_name->name;
    
    next = vast_cdr(next);
    if (vast_consp(next)) {
      uabort("defun args error!");
    }

    /* (args...) */
    obj = vast_car(next);
    if (obj) {
      int arg_idx = 0;
      if (vast_consp(obj)) {
	uabort("defun args invalid!");
      }
      args = obj;
      while (args != NULL) {
	vast_obj* arg;
	vast_symbol* sym;
	vps_data* data;

	arg = vast_car(args);
	if (vast_symbolp(arg)) {
	  uabort("arg not a symbol!");
	}
	sym = (vast_symbol*)arg;
	data = vps_any_new(jreq->vps,sym->name);
	if (!data) {
	  uabort("vps_any_new error!");
	}
	data->idx = arg_idx;
	data->scope = VPS_SCOPE_LOCAL;
	vcfg_grp_params_apd(grp,data);
	args = vast_cdr(args);
	arg_idx++;
      }
    }
    
    /* function body sequence
     * (body)...              */
    next = vast_cdr(next);
    while (next) {
      if (vast_consp(next)) {
	uabort("defun body not a cons!");
      }
      obj = vast_car(next);
      if (vast_consp(obj)) {
	uabort("defun body not a cons!");
      }
      vclosure_cons_call(closure,jreq,obj);
      next = vast_cdr(next);
    }
    
    inst = vps_ireturn(jreq->vps);
    vcfg_grp_inst_apd(grp,inst);
    vcfg_grp_build(jreq->vps,grp);
    vcfg_grp_connect(jreq->vps,grp);

    if (vclosure_child_add(jreq->closure,closure)) {
      uabort("add child closure error!");
    }

    VATTR_RETURN_VOID;
  })

/*
 * define attribute defvar
 * (defvar var)
 */
VDEFATTR(defvar,"defvar",{
  vps_closure_req* jreq;
  vast_obj* obj;
  vast_obj* next;
  vast_symbol* sym;
  vps_data* var;
  vcfg_graph* grp;
  
  jreq = (vps_closure_req*)req;
  grp = jreq->closure->init;
  
  next = vast_cdr(jreq->ast_obj);
  if (vast_consp(next)) {
      uabort("attr \"defvar\" has no args!");
  }
  obj = vast_car(next);
  if (vast_symbolp(obj)) {
    uabort("attr \"defvar\" variable not a symbol!");
  }
  sym = (vast_symbol*)obj;
  var = vclosure_curr_field_get(jreq->closure,sym->name);
  if (var) {
    uabort("variable already define!");
  }

  if (jreq->closure->parent) {
    var = vps_any_new(jreq->vps,sym->name);
    if (!var) {
      uabort("vps_any_new error!");
    }
    var->idx = grp->locals->count;
    var->scope = VPS_SCOPE_LOCAL;
    vcfg_grp_params_apd(grp,var);
  } else {
    if (vclosure_field_add(jreq->closure,var)) {
      uabort("attr \"defvar\" add field error!");
    }
  }

  VATTR_RETURN_VOID;
})

/*
 * define attribute if
 * (if (cond) (then) (else))
 */
VDEFATTR(if,"if",{
    vps_closure_req* jreq;
    vast_obj* obj;
    vast_obj* next;
    vps_inst* inst;
    vcfg_graph* grp;
    vps_id then_id;
    vps_id else_id;
    vps_id exit_id;

    jreq = (vps_closure_req*)req;
    grp = jreq->closure->init;

    then_id = vps_id_get(jreq->vps,NULL);
    else_id = vps_id_get(jreq->vps,NULL);
    exit_id = vps_id_get(jreq->vps,NULL);
    
    /* (cond...) */
    next = vast_cdr(jreq->ast_obj);
    if (vast_consp(next)) {
      uabort("ast attr \"if\" has no cond!");
    }
    obj = vast_car(next);
    if (vast_consp(obj)) {
      uabort("ast attr \"if\" cond has no ()!");
    }
    vclosure_cons_call(jreq->closure,jreq,obj);
    
    inst = vps_ijmpilb(jreq->vps,then_id);
    vcfg_grp_inst_apd(grp,inst);
    inst = vps_ijmplb(jreq->vps,else_id);
    vcfg_grp_inst_apd(grp,inst);
    
    /* (then...) */
    inst = vps_ilabel(jreq->vps,then_id);
    vcfg_grp_inst_apd(grp,inst);
    
    next = vast_cdr(next);
    if (vast_consp(next)) {
      uabort("ast attr \"if\" has no then!");
    }
    obj = vast_car(next);
    if (vast_consp(obj)) {
      uabort("ast attr \"if\" then has no ()!");
    }
    vclosure_cons_call(jreq->closure,jreq,obj);
    
    inst = vps_ijmplb(jreq->vps,exit_id);
    vcfg_grp_inst_apd(grp,inst);
    
    /* (else...) */
    inst = vps_ilabel(jreq->vps,else_id);
    vcfg_grp_inst_apd(grp,inst);

    next = vast_cdr(next);
    if (vast_consp(next)) {
      uabort("ast attr \"if\" has no else!");
    }
    obj = vast_car(next);
    if (vast_consp(obj)) {
      uabort("ast attr \"if\" else has no ()!");
    }
    vclosure_cons_call(jreq->closure,jreq,obj);

    inst = vps_ilabel(jreq->vps,exit_id);
    vcfg_grp_inst_apd(grp,inst);
    
    VATTR_RETURN_VOID;
})

/*
 * define attribute while
 * (while (cond) (loop)...)
 */
VDEFATTR(while,"while",{
    vps_closure_req* jreq;
    vast_obj* obj;
    vast_obj* next;
    vps_inst* inst;
    vcfg_graph* grp;
    vps_id cond_id;
    vps_id loop_id;
    vps_id exit_id;

    jreq = (vps_closure_req*)req;
    grp = jreq->closure->init;

    cond_id = vps_id_get(jreq->vps,NULL);
    loop_id = vps_id_get(jreq->vps,NULL);
    exit_id = vps_id_get(jreq->vps,NULL);

    /* (cond...) */
    inst = vps_ilabel(jreq->vps,cond_id);
    vcfg_grp_inst_apd(grp,inst);
    
    next = vast_cdr(jreq->ast_obj);
    if (vast_consp(next)) {
      uabort("ast attr \"while\" has no cond!");
    }
    obj = vast_car(next);
    if (vast_consp(obj)) {
      uabort("ast attr \"while\" cond has no ()!");
    }
    vclosure_cons_call(jreq->closure,jreq,obj);

    inst = vps_ijmpilb(jreq->vps,loop_id);
    vcfg_grp_inst_apd(grp,inst);
    inst = vps_ijmplb(jreq->vps,exit_id);
    vcfg_grp_inst_apd(grp,inst);

    /* (loop...) */
    inst = vps_ilabel(jreq->vps,loop_id);
    vcfg_grp_inst_apd(grp,inst);

    next = vast_cdr(next);
    if (vast_consp(next)) {
      uabort("ast attr \"while\" has no loop!");
    }
    obj = vast_car(next);
    if (vast_consp(obj)) {
      uabort("ast attr \"while\" loop has no ()!");
    }
    vclosure_cons_call(jreq->closure,jreq,obj);
    inst = vps_ijmplb(jreq->vps,cond_id);
    vcfg_grp_inst_apd(grp,inst);
    
    inst = vps_ilabel(jreq->vps,exit_id);
    vcfg_grp_inst_apd(grp,inst);

    VATTR_RETURN_VOID;
})

/*
 * define attribute add
 * (+ num...)
 */
VDEFATTR(add,"+",{
    vps_closure_req* jreq;
    vast_obj* obj;
    vast_obj* next;
    vps_inst* inst;
    vcfg_graph* grp;
    int argc = 0;

    jreq = (vps_closure_req*)req;
    grp = jreq->closure->init;
    next = vast_cdr(jreq->ast_obj);
    while (1) {
      if (!next) {
	if (argc < 2) {
	  uabort("attr \"+\" args less than 2!");
	}
	break;
      }
      obj = vast_car(next);
      if (!vast_consp(obj)) {
	vclosure_cons_call(jreq->closure,jreq,obj);
      } else {
        vclosure_arit_arg(jreq->closure,jreq->vps,obj);
      }
      if (argc > 0) {
	inst = vps_iadd(jreq->vps);
	vcfg_grp_inst_apd(grp,inst);
      }
      argc++;
      next = vast_cdr(next);
    }
    
    VATTR_RETURN_VOID;
})

/*
 * define attribute sub
 * (- num1 num2)
 */
VDEFATTR(sub,"-",{
    vps_closure_req* jreq;
    vast_obj* obj_num1;
    vast_obj* obj_num2;
    vast_obj* next;
    vps_inst* inst;
    vcfg_graph* grp;

    jreq = (vps_closure_req*)req;
    grp = jreq->closure->init;

    /* num2 */
    next = vast_cdr(jreq->ast_obj);
    if (vast_consp(next)) {
      uabort("attr \"-\" has no enought args!");
    }
    obj_num2 = vast_car(next);

    /* num1 */
    next = vast_cdr(next);
    if (vast_consp(next)) {
      uabort("attr \"-\" has no enough args!");
    }
    obj_num1 = vast_car(next);

    if (!vast_consp(obj_num1)) {
      vclosure_cons_call(jreq->closure,jreq,obj_num1);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj_num1);
    }

    if (!vast_consp(obj_num2)) {
      vclosure_cons_call(jreq->closure,jreq,obj_num2);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj_num2);
    }

    inst = vps_isub(jreq->vps);
    vcfg_grp_inst_apd(grp,inst);

    VATTR_RETURN_VOID;
})

/*
 * define attribute mul
 * (* num...)
 */
VDEFATTR(mul,"*",{
    vps_closure_req* jreq;
    vast_obj* obj;
    vast_obj* next;
    vps_inst* inst;
    vcfg_graph* grp;
    int argc = 0;

    jreq = (vps_closure_req*)req;
    grp = jreq->closure->init;

    /* num... */
    next = vast_cdr(jreq->ast_obj);
    while (1) {
      if (!next) {
	if (argc < 2) {
	  uabort("attr \"*\" args less than 2!");
	}
	break;
      }
      obj = vast_car(next);
      if (!vast_consp(obj)) {
	vclosure_cons_call(jreq->closure,jreq,obj);
      } else {
	vclosure_arit_arg(jreq->closure,jreq->vps,obj);
      }
      if (argc > 0) {
	inst = vps_imul(jreq->vps);
	vcfg_grp_inst_apd(grp,inst);
      }
      argc++;
      next = vast_cdr(next);
    }
    
    VATTR_RETURN_VOID;
})

/*
 * define attribute div
 * (/ num1 num2)
 */
VDEFATTR(div,"/",{
    vps_closure_req* jreq;
    vast_obj* obj_num1;
    vast_obj* obj_num2;
    vast_obj* next;
    vps_inst* inst;
    vcfg_graph* grp;

    jreq = (vps_closure_req*)req;
    grp = jreq->closure->init;

    /* num2 */
    next = vast_cdr(jreq->ast_obj);
    if (vast_consp(next)) {
      uabort("attr \"/\" has no enought args!");
    }
    obj_num2 = vast_car(next);

    /* num1 */
    next = vast_cdr(next);
    if (vast_consp(next)) {
      uabort("attr \"/\" has no enough args!");
    }
    obj_num1 = vast_car(next);

    if (!vast_consp(obj_num1)) {
      vclosure_cons_call(jreq->closure,jreq,obj_num1);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj_num1);
    }

    if (!vast_consp(obj_num2)) {
      vclosure_cons_call(jreq->closure,jreq,obj_num2);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj_num2);
    }
    
    inst = vps_idiv(jreq->vps);
    vcfg_grp_inst_apd(grp,inst);

    VATTR_RETURN_VOID;
})

/*
 * define attribute gt
 * (> num1 num2)
 */
VDEFATTR(gt,">",{
    vps_closure_req* jreq;
    vast_obj* obj_num1;
    vast_obj* obj_num2;
    vast_obj* next;
    vps_inst* inst;
    vcfg_graph* grp;

    jreq = (vps_closure_req*)req;
    grp = jreq->closure->init;

    /* num2 */
    next = vast_cdr(jreq->ast_obj);
    if (vast_consp(next)) {
      uabort("attr \">\" has no enought args!");
    }
    obj_num2 = vast_car(next);

    /* num1 */
    next = vast_cdr(next);
    if (vast_consp(next)) {
      uabort("attr \">\" has no enough args!");
    }
    obj_num1 = vast_car(next);

    if (!vast_consp(obj_num1)) {
      vclosure_cons_call(jreq->closure,jreq,obj_num1);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj_num1);
    }

    if (!vast_consp(obj_num2)) {
      vclosure_cons_call(jreq->closure,jreq,obj_num2);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj_num2);
    }
    
    inst = vps_igt(jreq->vps);
    vcfg_grp_inst_apd(grp,inst);
    
    VATTR_RETURN_VOID;
})

/*
 * define attribute lt
 * (< num1 num2)
 */
VDEFATTR(lt,"<",{
    vps_closure_req* jreq;
    vast_obj* obj_num1;
    vast_obj* obj_num2;
    vast_obj* next;
    vps_inst* inst;
    vcfg_graph* grp;

    jreq = (vps_closure_req*)req;
    grp = jreq->closure->init;

    /* num2 */
    next = vast_cdr(jreq->ast_obj);
    if (vast_consp(next)) {
      uabort("attr \"<\" has no enought args!");
    }
    obj_num2 = vast_car(next);

    /* num1 */
    next = vast_cdr(next);
    if (vast_consp(next)) {
      uabort("attr \"<\" has no enough args!");
    }
    obj_num1 = vast_car(next);

    if (!vast_consp(obj_num1)) {
      vclosure_cons_call(jreq->closure,jreq,obj_num1);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj_num1);
    }

    if (!vast_consp(obj_num2)) {
      vclosure_cons_call(jreq->closure,jreq,obj_num2);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj_num2);
    }
    
    inst = vps_ilt(jreq->vps);
    vcfg_grp_inst_apd(grp,inst);
    
    VATTR_RETURN_VOID;
})

/*
 * define attribute eq
 * (= num1 num2)
 */
VDEFATTR(eq,"=",{
    vps_closure_req* jreq;
    vast_obj* obj_num1;
    vast_obj* obj_num2;
    vast_obj* next;
    vps_inst* inst;
    vcfg_graph* grp;

    jreq = (vps_closure_req*)req;
    grp = jreq->closure->init;

    /* num2 */
    next = vast_cdr(jreq->ast_obj);
    if (vast_consp(next)) {
      uabort("attr \"=\" has no enought args!");
    }
    obj_num2 = vast_car(next);

    /* num1 */
    next = vast_cdr(next);
    if (vast_consp(next)) {
      uabort("attr \"=\" has no enough args!");
    }
    obj_num1 = vast_car(next);

    if (!vast_consp(obj_num1)) {
      vclosure_cons_call(jreq->closure,jreq,obj_num1);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj_num1);
    }

    if (!vast_consp(obj_num2)) {
      vclosure_cons_call(jreq->closure,jreq,obj_num2);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj_num2);
    }
    
    inst = vps_ieq(jreq->vps);
    vcfg_grp_inst_apd(grp,inst);
    
    VATTR_RETURN_VOID;
})

/*
 * define attribute set
 * (set var val)
 */
VDEFATTR(set,"set",{
    vps_closure_req* jreq;
    vast_obj* obj;
    vast_obj* next;
    vast_symbol* sym;
    vps_data* var;
    vcfg_graph* grp;
    vps_inst* inst;
    
    jreq = (vps_closure_req*)req;
    grp = jreq->closure->init;

    next = vast_cdr(jreq->ast_obj);
    if (vast_consp(next)) {
      uabort("attr \"set\" has no args!");
    }
    obj = vast_car(next);
    if (vast_symbolp(obj)) {
      uabort("attr \"set\" variable not a symbol!");
    }
    sym = (vast_symbol*)obj;
    var = vclosure_field_get(jreq->closure,sym->name);
    if (!var) {
      uabort("variable not define!");
    }

    next = vast_cdr(next);
    if (vast_consp(next)) {
      uabort("attr \"set\" has no enough args!");      
    }
    obj = vast_car(next);
    if (!vast_consp(obj)) {
      vclosure_cons_call(jreq->closure,jreq,obj);
    } else {
      vclosure_arit_arg(jreq->closure,jreq->vps,obj);
    }

    if (var->scope == VPS_SCOPE_LOCAL) {
      inst = vps_istoredt(jreq->vps,sym->name);
    } else if (var->scope == VPS_SCOPE_GLOBAL) {
      inst = vps_ipopdt(jreq->vps,grp,sym->name);
    } else {
      uabort("attr \"set\" var scope unknow!");
      inst = NULL;
    }
    vcfg_grp_inst_apd(grp,inst);

    VATTR_RETURN_VOID;
})

/*
 * declare attribute
 */
VATTRONLOAD(l5base,{
    VDECLATTR(defun);
    VDECLATTR(defvar);
    VDECLATTR(if);
    VDECLATTR(while);
    VDECLATTR(add);
    VDECLATTR(sub);
    VDECLATTR(mul);
    VDECLATTR(div);
    VDECLATTR(gt);
    VDECLATTR(lt);
    VDECLATTR(eq);
    VDECLATTR(set);
})
